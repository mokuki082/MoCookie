DROP SCHEMA Blockchain CASCADE;
CREATE SCHEMA IF NOT EXISTS Blockchain;

CREATE TABLE IF NOT EXISTS Blockchain.ValidUser (
  /* Represents a user in the system.*/
  pubk TEXT PRIMARY KEY
);

CREATE TABLE IF NOT EXISTS Blockchain.InvalidUser(
  pubk TEXT PRIMARY KEY
);

CREATE TABLE IF NOT EXISTS Blockchain.Transaction (
  /* Generic transaction class.

  Constraints:
    transaction_protocol_check -- Check that protocol is recognized
  */
  id SERIAL PRIMARY KEY,
  protocol VARCHAR(5) NOT NULL,
  CONSTRAINT transaction_protocol_check CHECK (protocol IN
    ('gct', 'rct', 'cct', 'ccct', 'pct', 'cpct', 'aut', 'rut'))
);

CREATE TABLE IF NOT EXISTS Blockchain.Block (
  /* Represents a block in the blockchain.

  Triggers:
    block_prev_hash_fkey -- Check that prev_hash is either all 0s or references
      the previous curr_hash.
  */
  id SERIAL PRIMARY KEY,
  curr_hash TEXT UNIQUE,
  prev_hash TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS Blockchain.GiveCookieTransaction (
  /* Represents a gc transaction

  Constraints:
    gct_invoker_ttime_key: Ensure no duplicated transaction.
    gct_num_cookies_check: Number of cookies cannot be 0 or negative.
  Trigger:
    gct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  invoker TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  transaction_time TIMESTAMP NOT NULL,
  receiver TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  recent_block INT REFERENCES Blockchain.Block(id) NOT NULL,
  num_cookies INT NOT NULL,
  reason VARCHAR(100),
  signature TEXT NOT NULL,
  -- Key constraint
  CONSTRAINT gct_invoker_ttime_key UNIQUE(invoker, transaction_time),
  -- Check constraint
  CONSTRAINT gct_num_cookies_check CHECK (num_cookies > 0)
);

CREATE TABLE IF NOT EXISTS Blockchain.ReceiveCookieTransaction (
  /* Represents a rc transaction

  Constraints:
    rct_invoker_ttime_key: Ensure no duplicated transaction.
    rct_num_cookies_check: Number of cookies cannot be 0 or negative.
  Trigger:
    rct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  invoker TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  transaction_time TIMESTAMP NOT NULL,
  sender TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  recent_block INT REFERENCES Blockchain.Block(id) NOT NULL,
  num_cookies INT NOT NULL,
  cookie_type VARCHAR(100),
  signature TEXT NOT NULL,
  -- Key constraint
  CONSTRAINT rct_invoker_ttime_key UNIQUE(invoker, transaction_time),
  -- Constraints
  CONSTRAINT rct_num_cookies_check CHECK (num_cookies > 0)
);

CREATE TABLE IF NOT EXISTS Blockchain.ChainCollapseTransaction (
  /* Represents a cc transaction

  Constraints:
    cct_invoker_ttime_key: Ensure no duplicated transaction.
  Trigger:
    cct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  invoker TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  transaction_time TIMESTAMP NOT NULL,
  recent_block INT REFERENCES Blockchain.Block(id) NOT NULL,
  signature TEXT NOT NULL,
  -- Primary key
  CONSTRAINT cct_invoker_ttime_key UNIQUE(invoker, transaction_time)
);

CREATE TABLE IF NOT EXISTS Blockchain.CombinedChainCollapseTransaction (
  /* Represents a ccc transaction

  Constraints:
    ccct_num_cookies_check: Number of cookies cannot be 0 or negative.
  Trigger:
    ccct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  start_user TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  mid_user TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  end_user TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  start_user_transaction INT REFERENCES Blockchain.ChainCollapseTransaction(id),
  mid_user_transaction INT REFERENCES Blockchain.ChainCollapseTransaction(id),
  end_user_transaction INT REFERENCES Blockchain.ChainCollapseTransaction(id),
  num_cookies INT NOT NULL,
  -- Constraints
  CONSTRAINT ccct_num_cookies_check CHECK (num_cookies > 0)
);

CREATE TABLE IF NOT EXISTS Blockchain.PairCancelTransaction (
  /* Represents a pc transaction

  Constraints:
    pct_invoker_ttime_key: Ensure no duplicated transaction.
  Trigger:
    pct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  invoker TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  transaction_time TIMESTAMP NOT NULL,
  recent_block INT REFERENCES Blockchain.Block(id) NOT NULL,
  signature TEXT NOT NULL,
  -- Constraints
  CONSTRAINT pct_invoker_ttime_key UNIQUE(invoker, transaction_time)
);

CREATE TABLE IF NOT EXISTS Blockchain.CombinedPairCancelTransaction (
  /* Represents a cpc transaction

  Constraints:
    cpct_num_cookies_check: Number of cookies cannot be 0 or negative.
  Trigger:
    cpct_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  user_a_id INT REFERENCES Blockchain.PairCancelTransaction(id),
  user_b_id INT REFERENCES Blockchain.PairCancelTransaction(id),
  user_a TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  user_b TEXT REFERENCES Blockchain.ValidUser(pubk) NOT NULL,
  num_cookies INT NOT NULL,
  -- Constraints
  CONSTRAINT cpct_num_cookies_check CHECK (num_cookies > 0)
);

CREATE TABLE IF NOT EXISTS Blockchain.AddUserTransaction (
  /* Represents a au transaction.

  Trigger:
    aut_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  join_time TIMESTAMP NOT NULL,
  user_pubk TEXT REFERENCES Blockchain.ValidUser(pubk) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS Blockchain.RemoveUserTransaction (
  /* Represents a ru transaction.

  Trigger:
    rut_protocol_check: Ensure all transactions are mutually exclusive.
  */
  id INT REFERENCES Blockchain.Transaction(id) PRIMARY KEY,
  remove_time TIMESTAMP NOT NULL,
  user_pubk TEXT REFERENCES Blockchain.ValidUser(pubk) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS Blockchain.IncludeTransaction (
  /* Shows the transactions in a block. */
  block TEXT REFERENCES Blockchain.Block(curr_hash),
  transaction_id INT REFERENCES Blockchain.Transaction(id),
  PRIMARY KEY(block, transaction_id)
);

CREATE TABLE IF NOT EXISTS Blockchain.Pool (
  /* Shows the transactions that are currently in the pool. */
  transaction_id INT PRIMARY KEY REFERENCES Blockchain.Transaction(id)
);

CREATE TABLE IF NOT EXISTS Blockchain.Debt (
  /* Shows the debt between two users

  Constraint:
    debt_cookies_owed_check -- cookies_owed cannot be negative.
  */
  sender_pubk TEXT REFERENCES Blockchain.ValidUser(pubk),
  receiver_pubk TEXT REFERENCES Blockchain.ValidUser(pubk),
  cookies_owed INT DEFAULT 0 NOT NULL,
  PRIMARY KEY(sender_pubk, receiver_pubk),
  -- Constraints:
  CONSTRAINT debt_cookies_owed_check CHECK (cookies_owed >= 0)
);
CREATE OR REPLACE FUNCTION Blockchain.checkPreviousHashFKey()
  RETURNS trigger AS
  /* Check that the previous_hash is valid. */
  $$
    DECLARE
      genesis_hash CONSTANT TEXT := '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
    BEGIN
      IF (NEW.ordering = 1 AND NEW.prev_hash = gensis_hash) THEN
        -- Genesis block must have a all 0 prev_hash
        RETURN NEW;
      ELSEIF (NEW.prev_hash = (SELECT curr_hash
                               FROM Blockchain.Block
                               WHERE NEW.id - 1 = id)) THEN
        -- Non-genesis block must have previuos block's hash as prev_hash
        RETURN NEW;
      ELSE
        RAISE EXCEPTION 'Invalid prev_hash.';
      END IF;
    END
  $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS block_prev_hash_fkey ON Blockchain.Block;
CREATE TRIGGER block_prev_hash_fkey
  /* Check that the previous_hash is valid. */
  BEFORE INSERT OR UPDATE OF curr_hash, prev_hash ON Blockchain.Block
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkPreviousHashFKey();


CREATE OR REPLACE FUNCTION Blockchain.checkTransactionMutualExcl()
  RETURNS trigger AS
  /* Check that all transaction subclasses are mutually exclusive. */
  $$
    DECLARE
      occ INT;
    BEGIN
      occ := (SELECT COUNT(*)
              FROM Blockchain.GiveCookieTransaction as gct
              CROSS JOIN Blockchain.ReceiveCookieTransaction as rct
              CROSS JOIN Blockchain.ChainCollapseTransaction as cct
              CROSS JOIN Blockchain.CombinedChainCollapseTransaction as ccct
              CROSS JOIN Blockchain.PairCancelTransaction as pct
              CROSS JOIN Blockchain.CombinedPairCancelTransaction as cpct
              CROSS JOIN Blockchain.AddUserTransaction as aut
              CROSS JOIN Blockchain.RemoveUserTransaction as rut
              WHERE gct.id = NEW.id OR rct.id = NEW.id OR
                    cct.id = NEW.id OR cpct.id = NEW.id OR
                    pct.id = NEW.id OR cpct.id = NEW.id OR
                    aut.id = NEW.id OR rut.id = NEW.id);
      IF (occ == 1) THEN
        RETURN NULL;
      ELSEIF (occ == 1) THEN
        RAISE EXCEPTION 'Transaction is not mutually exclusive.';
      ELSE
        RAISE EXCEPTION 'Transaction does not exist.';
      END IF;
    END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS gct_mutualexcl_check
  ON Blockchain.GiveCookieTransaction;
CREATE TRIGGER gct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.GiveCookieTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS rct_mutualexcl_check
  ON Blockchain.ReceiveCookieTransaction;
CREATE TRIGGER rct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.ReceiveCookieTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS cct_mutualexcl_check
  ON Blockchain.ChainCollapseTransaction;
CREATE TRIGGER cct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.ChainCollapseTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS ccct_mutualexcl_check
  ON Blockchain.CombinedChainCollapseTransaction;
CREATE TRIGGER ccct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.CombinedChainCollapseTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS pct_mutualexcl_check
  ON Blockchain.PairCancelTransaction;
CREATE TRIGGER pct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.PairCancelTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS cpct_mutualexcl_check
  ON Blockchain.CombinedPairCancelTransaction;
CREATE TRIGGER cpct_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.CombinedPairCancelTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS aut_mutualexcl_check
  ON Blockchain.AddUserTransaction;
CREATE TRIGGER aut_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.AddUserTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

DROP TRIGGER IF EXISTS rut_mutualexcl_check
  ON Blockchain.RemoveUserTransaction;
CREATE TRIGGER rut_mutualexcl_check
  /* Check that transactions are mutually exclusive. */
  AFTER INSERT OR UPDATE OF id ON Blockchain.RemoveUserTransaction
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.checkTransactionMutualExcl();

CREATE OR REPLACE FUNCTION Blockchain.addToInvalidUser()
  RETURNS trigger AS
  /* Insert user into InvalidUser upon deletion */
  $$
  BEGIN
    INSERT INTO Blockchain.InvalidUser(pubk) VALUES (OLD.pubk);
  END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS rut_mutualexcl_check
  ON Blockchain.RemoveUserTransaction;
CREATE TRIGGER rut_mutualexcl_check
  /* Insert user into InvalidUser upon deletion */
  AFTER DELETE ON Blockchain.ValidUser
  FOR EACH ROW
  EXECUTE PROCEDURE Blockchain.addToInvalidUser();
CREATE OR REPLACE FUNCTION Blockchain.AddUser(pubk TEXT)
  RETURNS VOID AS
  $$
  BEGIN
    INSERT INTO Blockchain.ValidUser(pubk) VALUES (pubk);
  END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION Blockchain.RemoveUser(pubk TEXT)
  RETURNS VOID AS
  $$
  BEGIN
    DELETE FROM Blockchain.ValidUser vu WHERE vu.pubk = pubk; 
  END
  $$

CREATE OR REPLACE FUNCTION Blockchain.AddGiveCookieTransaction(
      invoker TEXT,
      transaction_time DOUBLE PRECISION, -- unix time
      receiver TEXT,
      recent_hash TEXT,
      num_cookies INT,
      reason VARCHAR(100),
      signature TEXT)
  RETURNS VOID AS
  $$
    DECLARE
      tid INT;
      bid INT;
      ttime TIMESTAMP;
    BEGIN
      -- Create a generic transaction
      INSERT INTO Blockchain.Transaction(protocol) VALUES ('gct');
      -- Obtain transaction_id
      tid := (SELECT id
                 FROM Blockchain.Transaction
                 ORDER BY id
                 LIMIT 1);
      -- Obtain block_id
      bid := (SELECT id
                 FROM Blockchain.Block
                 WHERE curr_hash = recent_hash);
      -- Convert unix time into timestamp format
      ttime := to_timestamp(transaction_time);
      -- Create GiveCookieTransaction
      INSERT INTO Blockchain.GiveCookieTransaction(
        id, invoker, transaction_time, receiver, recent_block,
        num_cookies, reason, signature
      ) VALUES (tid, ttime, receiver, bid, num_cookies, reason, signaure);
    END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION Blockchain.AddReceiveCookieTransaction(
      invoker TEXT,
      transaction_time DOUBLE PRECISION,
      sender_pubk TEXT,
      recent_hash TEXT,
      num_cookies INT,
      cookie_type VARCHAR(100),
      signature TEXT)
  RETURNS VOID AS
  $$
    BEGIN
      -- Create a generic transaction
      -- Obtain transaction_id
      -- Obtain block_id
      -- Create GiveCookieTransaction
    END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION Blockchain.AddCollapseChainTransaction(
      invoker TEXT,
      transaction_time DOUBLE PRECISION,
      recent_hash TEXT,
      start_user TEXT,
      mid_user TEXT,
      end_user TEXT,
      num_cookies INT,
      signature TEXT)
  RETURNS VOID AS
  $$
    BEGIN
      -- Create a generic transaction
      -- Obtain transaction_id
      -- Obtain block_id
      -- Create GiveCookieTransaction
      -- Create CollapseChainTransaction
      -- Check if CombinedCollapseChainTransaction exists
      -- If yes, update the combined transaction
      -- Otherwise create a combined transaction
    END
  $$ LANGUAGE plpgsql SECURITY DEFINER;

--
-- CREATE OR REPLACE FUNCTION Blockchain.AddPairCalcelTransaction(
--   invoker TEXT,
--   other TEXT,
--   transaction_time DOUBLE PRECISION,
--   recent_block INT,
--   signature TEXT
-- );
